# 上机大礼包  


## 浮点数攻略

浮点数，看起来是一个十分简单的东西。要是你直接把它和整型对比，会发现它范围比整型大，除法时不是整除……既然有这么一个看起来比整型好得多的东西，为什么不一直用他呢？

### 浮点数不是那么好

一个系统的设计是需要权衡的，一个东西当然不可能每个方面都做的很好。浮点数为了可以表示小数（或者说为了可以表示指数），牺牲了一些空间来记录次幂。因此，如果用它来表示整数，如果在不损失精度的前提下，他的真正的范围是比不上整型的（比如一个很大的数，它只能记录一个有限的精度，然后像科学计数法那样记录这个数的指数）。同时，它表示的是一个二进制的小数，因此如果它表示一个十进制小数，可能会出现精度问题。（比如1.3这个数，你就转化不成二进制小数）（至于浮点数究竟是怎么记录的嘛，大概就是像科学计数法那样记录次幂，不过是二进制的科学计数法（具体可以看课程内容））

### 什么时候你要用它

+ 计算的结果是一个小数的时候，同时你不需要保证极高的精度的时候。
+ 你要记录一个很大的数，同时你不需要保证很高的精度的时候。
+ ……（其实基本没有其他情况了）
+ 不要去盲目使用浮点数，因为一旦你使用了浮点数，就意味着你算出的结果会是一个近似值。

*（这里的精度是指数字的整数部分和小数部分总共的位数）*

### 浮点数的相等——涉及浮点数的题目的一大陷阱

$1.4 \ne 1.39999999999999999979823192$ 这是数学上一个显而易见的常识

然而，如果在使用浮点数进行逻辑判断时，还这么认为，就不一定了。

简单的说，$7\div5$的结果，使用浮点数计算出来时，就不一定刚好是$1.4$了（实际上也一定不是）

*浮点数表示的是一个二进制小数，而像1.4这种数，是没有完整对应的二进制小数的，因此记录的只是一个约等于1.4的结果*

那么，如果有两个运算的结果都是1.4，但由于各种原因他们计算的浮点数保存的值不一样(比如一个1.3999999，一个1.40000000001)，你使用$==$符号得出的结果就不一样了。

这时候，就需要引入一个新的定义——什么样的浮点数才是相等的？



通常，我们会定义一个误差上限Epsilon,差距小于这个Epsilon的两个数我们认为是相同的，否则就可以认为是不同的。（如果你会误差分析的话，其实你还可以用其他方法进行判断。但是这里我们用这个最简单的方法）



这样，如果有因为数的舍入或者除法运算的误差导致的误差，只要它小于Epsilon，就不会造成影响。当然，这有可能导致两个不相同的数被判断为相同，这时，我们就需要灵活设定Epsilon的大小了。通常，我们会设定其为$10^{-5}$~$10^{-8}$之间。



这里演示一个写法：

比如我们要判断一个二次方程的Δ是不是0。

```c
const double eps = 1e-6; // 设定Epsilon的大小

int sgn(double x)
{
    if (x > eps) {
        return 1;
    } else if （x < eps) {
        return -1;
    } else {
        return 0;
    }
}

int main(){
    double a = 1.5, b = 3.0, c = 1.5;
    double delta = b * b - 4 * a * c;
    if (sgn(x) == 0) {
        printf("Delta equals 0!");
    } else {
        printf("Delta not equals 0!");
    }
    return 0;
}
```

这里使用了一个函数
$$
sgn(x)=\begin{cases}
-1 && x<0 \\
1 && x>0 \\
0 && x=0
\end{cases}
$$
还记得之前我们说的判断相等的方法吗，等于0其实相当于$|x-0| \le eps$

因此其实是
$$
sgn(x)=\begin{cases}
-1 && x<-eps \\
1 && x>eps \\
0 && -eps \le x \le eps
\end{cases}
$$
因此，如果要判断一个数是否大于零，可以写成 `if (sgn(x) > 0)`

同理 小于零是 `if (sgn(x) > 0)`，大于等于零是 `if (sgn(x) >= 0)`,小于等于零是`if (sgn(x) <= 0)`

当然，如果你要判断一个数是否大于、大于等于、小于、小于等于另一个数，你也可以像`if (sgn(a-b) > 0)`这么写。

### 浮点数与强制转换

很多时候，再读入的时候，你会使用`int`进行读入，但是这个时候,你可能又会因为除法等原因，需要将其强制转化为一个浮点数。

当我们使用`(double)`强制转换时，我们只会对`(double)`这个东西后面的那个变量/运算结果进行转换，也就是说，如果后面是一个括号包起来的表达式，只会在表达式运算完成后在对结果进行转换，这样，过程中如果出现除法，就可能会导致直接整除去尾的情况。

有时候，如果搞不清强制转换的规则，可以在出现除法时，对所有整数都进行一个强制转换。

### 浮点数与输出

输出浮点数，相信大家都是会的。这里教大家一个奇技淫巧：

```c
int main()
{
    int length = 7;
    double f = 1.12345678910;
    printf("%.*lf", length, f); // * 是 length 变量
}
```

这里，在控制长度的时候，可以使用*表示一个数字。





## 你所未见的字符

先简单说说字符串吧，它的本质是一个字符数组，是一堆挨在一起的字符。

在读入它的时候，使用`scanf("%s", s);`，注意没有读地址符号`&`。

`%s`在遇到空格和换行符时都会停止读入，如果要读取一整行，可以去看看`fgets`。

这里，我们主要讲的一些不可见字符：`\n`,`\r`和`\0`。

### \r\n  

Windows下换行符号是`\r\n`(windows下判断时只判断`\n`)，而linux的换行是`\n`没有`\r`。

助教在生成测试数据的时候，一般是在Windows环境下，而我们的评测系统是在linux环境下的，当我们一个一个读入字符的时候，在linux下可能会读入到`\r`，写代码时要注意做好判断。

### \0  

这个字符是字符串结束的标志位，它的ASCII码是0。

你读入的每个字符串的末尾都会被加上这个符号。

在输出字符串的时候，`printf`也会在遇到它的时候停下。

## 代码风格

大张和小丁是好朋友，他们今天在讨论周二的上机题：统计一行字符中有多少个字符为`a`。

大张： 小丁，你的代码看起来很舒服啊。
小丁： 因为写代码的时候不只需要考虑完成任务，还要考虑自己后续**阅读、改进和debug**

大张的代码

```c
#include <stdio.h>
#include <string.h>
int main() {
char str[1010];
int i,len,cnt;
scanf("%s",str);
len=strlen(str);
for(i=0,cnt=0;i<len;i++){
if (str[i]=='a'){cnt++;}
}
printf("%d\n",cnt);
return 0;
}
```
小丁的代码
```c
#include <stdio.h>
#include <string.h>
#define MAXN 1010
int main() {
    // input data
    char str[MAXN]={0};
    // loop var
    int i;
    // output data
    int cnt = 0;
    
    scanf("%s",str);
    len = strlen(str);
    
    for (i=0;i<len;i++)
        cnt += (str[i] == 'a')
    
    printf("%d\n",cnt);
    return 0;
}
```

大张：明明我们的代码没什么区别，为什么你的代码看起来如此好看呢？
小丁说它的代码有如下几个秘诀：

1. 用宏定义避免出现无意义数字。
2. 有合适的缩进，`for/if/while`等关键字后表示同一个代码块进行缩进
3. 有合适的注释，意义不相关的变量不要定义在一起。
4. 一行出现的代码要注意间距、作用要相似。
5. 大部分变量应当初始化！

大张：那我现在没怎么养成习惯，有什么快速的方法么？
小丁：在`dev-c++`有快捷键`Ctrl+Shift+A`，在`Code::blocks`可以右键选择`format use AStyle`当然最好的是自己养成好习惯哦。**好的代码风格非常有助于debug哦**。

## 学长小课堂——思考的乐趣

小雨和小丁在讨论这次上机的最后一题：删除一个二进制数的某一位、使得剩下的二进制数最大。

小雨：这题怎么做啊，我不会处理全是`1`的情况，我怎么知道有多少个一呢？
小丁：这题要用字符串啊，他们还没讲字符串，所以你*做不起*啊。
小雨沮丧的走开了，路上碰到了Ange。
学长：小雨，你怎么了，有什么不开心么？
小雨：上次上机的最后一题要用字符串，大佬说我不会，这谁还做的起啊？
学长：小雨不要沮丧，其实这个题不用沮丧也可以做的，你看看我的代码。

```c
#include <stdio.h>
int main(){
	// input data
	char buf,nxt;
	// flag
	int flag = 0;

	scanf("%c",&buf);
	while (~scanf("%c",&nxt)) {
		if (nxt != '0' && nxt != '1') break;
		if (buf == '0' && flag == 0)
			flag = 1;
		else 
			printf("%c",buf);
		buf = nxt;
	}
	if (flag) 
		printf("%c",buf); 
	return 0;
}
```
小雨：诶，真的没用字符串诶，这是怎么做到的呢？我只知道如果有零要删除一个零就是最优解。
学长：我给你解释一下，由于我尚不知道当前字符是否是最后一个字符，所以我可以每次多保存一个字符，当下一次未读入到字符的时候，我现在读到的字符就是最后一个字符。这样就解决了，我知道最后一个数字字符（注意到结尾可能有`\n`），而且还没有输出。就可以决定是否输出最后一个字符了！
小雨：原来不用像大佬一样，会很多高级东西就能做题，只要稍微想想就好了，谢谢学长。

**希望，任何人，不要利用自己提前学过的小聪明、夺取别人思考的乐趣。** 在没有集成开发环境、没有大内存设备的过去、都有人能利用计算机做很多事情，今天的我们不必**束手束脚**，但不代表我们不需要思考，通过自己的一些小思考，解决问题、会收获很多快乐。