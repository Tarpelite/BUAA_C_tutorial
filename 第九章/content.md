# 递归

## 啥是递归 

话说，说到递归的定义，咳咳

````
递归的定义如下：
递归：
如果没明白递归是什么意思，参见“递归”。

----《算法竞赛入门经典》刘汝佳
````  

没错，递归就是“我用我自己”——自己不断调用自己。
在一个函数中，为了得到一个“子结果”，调用自己这个函数来计算，而往往计算子结果的时候，需要计算的问题规模会下降。这样最后可以得到一个不用计算就可以直接得到的答案的规模，然后把这个答案层层返回。当然，如果最后一直无法得到一个结果，无限调用下去，就变成了无限递归。
当然，有时候，多个过程互相调用，间接的用到自己，（比如A调用B，B调用C，C调用A），也算是一种递归。

这是一个在编程时很普遍的思想，当你要解决一个问题时，你可通过一些方法使用 **降低了问题的规模**的结果 加上一些计算得到目前需要的结果，这时候，就可以通过递归来计算问题。

## 一个例子  

比如，函数
$$
f(n)=\begin{cases}
1 && {n=0} \\
f(n-1) \times n && {n>0} \\
\end{cases}
$$
就是一个递归定义的函数

假设我们要写一个程序(函数)来计算$f(n)$
如果$n$为$0$，则结果是$1$，我们直接```return 1;```
如果$n>0$，则我们计算的结果是```f(n-1)*n```。
这里，可能有的同学会疑惑，如何计算f(n-1)呢，很简单，我们调用自己这个函数，让他来计算f(n-1)，即```return calc_f(n-1)*n;```  

```` c
int calc_f(int n)
{
	if(n==0)
		return 1;
	else
		return calc_f(n-1)*n;
}
````  

这就是一个简单的递归程序。

## 更多的例子

###阿克曼函数：
$$
A(m,n)=\begin{cases}
n+1 && {m=0} \\
A(m-1,1) && {m>0 \wedge n=0} \\
A(m-1,A(m,n-1)) && {m>0 \wedge n>0} 
\end{cases}
$$

就有递归过程：
1. 如果当前m为0，则返回1
2. 如果不是1且当前n为0，则调用A(m-1,1),并将其的返回值返回
3. 如果均不是以上两种情况，则调用A(m,n-1),假设其返回值为a，调用A(m-1,a),并将此值返回。

###倒序输出
给出若干个在数，将它们倒序输出。
例如输入
```
1 3 4 2 5
```
输出
```
5 2 4 3 1
```
同样可以考虑一个递归过程：
1. 尝试读取一个数字，读取失败（末尾）直接返回
2. 如果读取成功，那么调用自身
3. 调用自身结束之后，输出读取到的数字

以上三个例子，当我们思考如何递归时，都有着这么一个过程：
1. 判断是否为“终止”，即是否可以直接得到值。
2. 如果是，则返回该值
3. 如果不是，则调用自身，之后再返回。

##递归调用时，电脑在干什么？
##递归过深和段错误
//（这两节过于难，暂时删去）


## 参考资料  

《算法竞赛入门经典 第二版》.刘汝佳